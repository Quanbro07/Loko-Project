import requests
import json
import time
import sys
import math

# ======================= C·∫§U H√åNH =======================
# Ch·ªâ c·∫ßn M·ªòT API key c·ªßa Geoapify
GEOAPIFY_API_KEY = "936a7ef652bd479d8fb93d36dc2e1a3e"

INPUT_FILE = "attractions_with_tags.json"
OUTPUT_FILE = "time_matrix.txt"

# API Endpoints c·ªßa Geoapify
GEOAPIFY_MATRIX_URL = f"https://api.geoapify.com/v1/routematrix?apiKey={GEOAPIFY_API_KEY}"
GEOAPIFY_REVGEOCODE_URL = "https://api.geoapify.com/v1/geocode/reverse"

GEOAPIFY_PLACES_URL = "https://api.geoapify.com/v2/places"

# N·∫øu 90% ƒë∆∞·ªùng ƒëi t·ª´ m·ªôt ƒëi·ªÉm b·ªã l·ªói (-1), coi ƒë√≥ l√† t·ªça ƒë·ªô h·ªèng
FAILURE_THRESHOLD = 0.50
# ========================================================


def load_original_locations(input_file):
    """ƒê·ªçc file JSON g·ªëc ƒë·ªÉ l·∫•y 'title' v√† t·ªça ƒë·ªô g·ªëc."""
    try:
        with open(input_file, 'r', encoding='utf-8') as f:
            return json.load(f)
    except FileNotFoundError:
        print(f"L·ªói: Kh√¥ng t√¨m th·∫•y file '{input_file}'.")
        return []
    except json.JSONDecodeError:
        print(f"L·ªói: File '{input_file}' kh√¥ng ph·∫£i l√† JSON h·ª£p l·ªá.")
        return []

def prepare_geoapify_locations(original_locations):
    """
    Chu·∫©n b·ªã danh s√°ch t·ªça ƒë·ªô cho Geoapify [lng, lat] t·ª´ danh s√°ch ƒë·ªëi t∆∞·ª£ng g·ªëc.
    """
    api_locations = []
    for loc in original_locations:
        if 'latitude' in loc and 'longitude' in loc:
            coords = [loc['longitude'], loc['latitude']]
            api_locations.append({"location": coords})
        else:
            api_locations.append(None) # Th√™m placeholder n·∫øu thi·∫øu t·ªça ƒë·ªô
    return api_locations

def send_geoapify_request(origin_locations, target_locations):
    """G·ª≠i m·ªôt y√™u c·∫ßu POST ƒë·∫øn API routematrix."""
    headers = {"Content-Type": "application/json"}
    body = {
        "mode": "drive",
        "sources": origin_locations,
        "targets": target_locations
    }
    
    try:
        response = requests.post(GEOAPIFY_MATRIX_URL, headers=headers, data=json.dumps(body))
        response.raise_for_status() 
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"L·ªói k·∫øt n·ªëi (Geoapify Matrix): {e}")
    return None

def build_matrix_rows_from_response(response):
    """X·ª≠ l√Ω JSON, chuy·ªÉn 'null' ho·∫∑c l·ªói th√†nh -1."""
    matrix_rows = []
    results = response.get('sources_to_targets')
    if not results: return []

    for row in results:
        row_durations = []
        for element in row:
            time_value = element.get('time') if element else None
            row_durations.append(time_value if time_value is not None else -1)
        matrix_rows.append(row_durations)
    return matrix_rows

def create_time_matrix(api_locations):
    """H√†m ch√≠nh ƒë·ªÉ t·∫°o ma tr·∫≠n, √°p d·ª•ng logic chia l√¥ (batching) 1000 elements."""
    num_locations = len(api_locations)
    if num_locations == 0: return []

    valid_locations = [loc for loc in api_locations if loc is not None]
    valid_indices = [i for i, loc in enumerate(api_locations) if loc is not None]
    
    if not valid_locations:
        return [[-1] * num_locations for _ in range(num_locations)]

    num_valid = len(valid_locations)
    max_elements_per_request = 1000
    max_rows_per_request = max(1, max_elements_per_request // num_valid) # ƒê·∫£m b·∫£o √≠t nh·∫•t l√† 1
    
    q, r = divmod(num_valid, max_rows_per_request)
    total_requests = q + (1 if r > 0 else 0)
    
    valid_matrix = [] 
    print(f"\nT·ªïng s·ªë ƒë·ªãa ƒëi·ªÉm h·ª£p l·ªá: {num_valid}/{num_locations}")
    print(f"S·∫Ω th·ª±c hi·ªán {total_requests} request ƒë·∫øn Geoapify Matrix...")
    
    for i in range(q + (1 if r > 0 else 0)):
        start = i * max_rows_per_request
        end = (i + 1) * max_rows_per_request if i < q else num_valid
        origin_locations = valid_locations[start:end]
        
        response = send_geoapify_request(origin_locations, valid_locations)
        if response:
            valid_matrix.extend(build_matrix_rows_from_response(response))
        else:
            for _ in origin_locations: valid_matrix.append([-1] * num_valid)
        time.sleep(1)

    # M·ªü r·ªông ma tr·∫≠n (Re-inflate)
    full_matrix = [[-1] * num_locations for _ in range(num_locations)]
    for i, valid_i in enumerate(valid_indices):
        for j, valid_j in enumerate(valid_indices):
            if i < len(valid_matrix) and j < len(valid_matrix[i]):
                 full_matrix[valid_i][valid_j] = valid_matrix[i][j]
            
    return full_matrix

def find_bad_location_indices(matrix):
    """Ph√¢n t√≠ch ma tr·∫≠n ƒë·ªÉ t√¨m c√°c h√†ng b·ªã l·ªói (to√†n -1)."""
    bad_indices = []
    if not matrix: return []
    num_locations = len(matrix)
    
    for i, row in enumerate(matrix):
        errors_in_row = sum(1 for j, time in enumerate(row) if time == -1 and i != j)
        total_paths = num_locations - 1
        
        if total_paths > 0 and (errors_in_row / total_paths) >= FAILURE_THRESHOLD:
            bad_indices.append(i)
            
    return bad_indices

def get_corrected_location_geoapify(latitude, longitude):
    """
    S·ª¨A L·ªñI: D√πng Geoapify Places API ƒë·ªÉ t√¨m B√ÉI ƒê·ªñ XE (parking)
    g·∫ßn nh·∫•t v·ªõi t·ªça ƒë·ªô b·ªã l·ªói.
    """
    RADIUS_METERS = 5000 # T√¨m trong b√°n k√≠nh 5km

    params = {
        # Y√™u c·∫ßu: t√¨m b√£i ƒë·ªó xe, ho·∫∑c b√£i ƒë·ªó xe ƒë·∫°p
        "categories": "parking", 
        "filter": f"circle:{longitude},{latitude},{RADIUS_METERS}",
        "limit": 1, # Ch·ªâ c·∫ßn 1 k·∫øt qu·∫£ g·∫ßn nh·∫•t
        "apiKey": GEOAPIFY_API_KEY
    }
    
    try:
        # S·ª¨ D·ª§NG ENDPOINT M·ªöI (GEOAPIFY_PLACES_URL)
        response = requests.get(GEOAPIFY_PLACES_URL, params=params) 
        response.raise_for_status()
        data = response.json()
        
        # Ph·∫£n h·ªìi Places API c√≥ c·∫•u tr√∫c "features"
        if data.get("features"):
            first_result = data["features"][0]
            properties = first_result.get("properties", {})
            
            # T·ªça ƒë·ªô n·∫±m trong "properties"
            corrected_lon = properties.get("lon")
            corrected_lat = properties.get("lat")
            
            if corrected_lon and corrected_lat:
                print(f"    -> ƒê√£ t√¨m th·∫•y b√£i ƒë·ªó xe/l·ªëi v√†o: {properties.get('name', properties.get('address_line1', 'N/A'))}")
                # Tr·∫£ v·ªÅ ƒë·ªëi t∆∞·ª£ng location ƒë√∫ng ƒë·ªãnh d·∫°ng [lng, lat]
                return {"location": [corrected_lon, corrected_lat]}
            else:
                print(f"    -> ƒê√£ t√¨m th·∫•y b√£i ƒë·ªó xe, nh∆∞ng kh√¥ng c√≥ t·ªça ƒë·ªô.")

        else:
            print("    -> Kh√¥ng t√¨m th·∫•y b√£i ƒë·ªó xe n√†o trong b√°n k√≠nh 5km.")

    except requests.exceptions.HTTPError as http_err:
        print(f"    -> L·ªói HTTP (Geoapify Places): {http_err}")
    except requests.exceptions.RequestException as e:
        print(f"    -> L·ªói k·∫øt n·ªëi (Geoapify Places): {e}")
        
    return None # Tr·∫£ v·ªÅ None n·∫øu s·ª≠a l·ªói th·∫•t b·∫°i

def save_matrix_to_txt(matrix, filename):
    """L∆∞u ma tr·∫≠n 2D v√†o file .txt."""
    try:
        with open(filename, 'w', encoding='utf-8') as f:
            for row in matrix:
                f.write(" ".join(str(e) for e in row) + "\n")
        print(f"\nüéâ ƒê√£ l∆∞u ma tr·∫≠n v√†o file: {filename}")
    except IOError as e:
        print(f"L·ªói khi ghi file output: {e}")

# --- H√ÄM MAIN (QUY TR√åNH CH√çNH) ---
def main():
    if GEOAPIFY_API_KEY == "YOUR_GEOAPIFY_API_KEY":
        print("L·ªñI: Vui l√≤ng c·∫•u h√¨nh GEOAPIFY_API_KEY.")
        sys.exit(1)
        
    # 1. T·∫£i d·ªØ li·ªáu g·ªëc (ƒë·ªÉ l·∫•y 'title' v√† t·ªça ƒë·ªô g·ªëc)
    original_locations = load_original_locations(INPUT_FILE)
    if not original_locations: return
    
    print(f"ƒê√£ t·∫£i {len(original_locations)} ƒë·ªãa ƒëi·ªÉm t·ª´ {INPUT_FILE}.")
    
    # 2. Chu·∫©n b·ªã t·ªça ƒë·ªô [lng, lat] cho Geoapify
    api_locations = prepare_geoapify_locations(original_locations)

    # 3. CH·∫†Y L·∫¶N 1 (TEST RUN)
    print("\n--- B·∫Øt ƒë·∫ßu Ch·∫°y Th·ª≠ (L·∫ßn 1) ƒë·ªÉ t√¨m l·ªói ---")
    matrix_pass1 = create_time_matrix(api_locations)
    
    if not matrix_pass1:
        print("Kh√¥ng th·ªÉ t·∫°o ma tr·∫≠n l·∫ßn 1. D·ª´ng l·∫°i.")
        return

    # 4. PH√ÅT HI·ªÜN L·ªñI
    bad_indices = find_bad_location_indices(matrix_pass1)
    
    if not bad_indices:
        print("\nüéâ Kh√¥ng t√¨m th·∫•y t·ªça ƒë·ªô l·ªói. Ma tr·∫≠n h·ª£p l·ªá.")
        save_matrix_to_txt(matrix_pass1, OUTPUT_FILE)
        sys.exit(0)
        
    # 5. S·ª¨A L·ªñI (N·∫øu t√¨m th·∫•y)
    print(f"\n--- Ph√°t hi·ªán {len(bad_indices)} t·ªça ƒë·ªô l·ªói. B·∫Øt ƒë·∫ßu T·ª± ƒë·ªông S·ª≠a ---")
    
    corrected_api_locations = api_locations.copy()
    
    for index in bad_indices:
        location = original_locations[index]
        location_name = location.get('title', f"ƒê·ªãa ƒëi·ªÉm {index}")
        print(f"ƒêang s·ª≠a: {location_name} (Index: {index})...")
        
        # L·∫•y t·ªça ƒë·ªô g·ªëc (lat, lon)
        lat = location.get('latitude')
        lon = location.get('longitude')
        
        if lat and lon:
            # G·ªçi API Reverse Geocode c·ªßa Geoapify
            new_location_object = get_corrected_location_geoapify(lat, lon)
            
            if new_location_object:
                corrected_api_locations[index] = new_location_object
            else:
                print(f"    -> KH√îNG TH·ªÇ s·ª≠a l·ªói cho {location_name}. S·∫Ω gi·ªØ l·ªói -1.")
        else:
             print(f"    -> B·ªè qua {location_name} v√¨ thi·∫øu t·ªça ƒë·ªô g·ªëc.")
            
    # 6. CH·∫†Y L·∫¶N 2 (FINAL RUN)
    print("\n--- B·∫Øt ƒë·∫ßu Ch·∫°y L·∫°i (L·∫ßn 2) v·ªõi t·ªça ƒë·ªô ƒë√£ s·ª≠a ---")
    matrix_pass2 = create_time_matrix(corrected_api_locations)
    
    # 7. L∆ØU K·∫æT QU·∫¢
    save_matrix_to_txt(matrix_pass2, OUTPUT_FILE)
    print("\n--- ƒê√£ ho√†n t·∫•t v√† l∆∞u ma tr·∫≠n ƒë√£ s·ª≠a ---")

if __name__ == "__main__":
    main()